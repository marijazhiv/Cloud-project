{
  "version": 3,
  "sources": ["../../../../../node_modules/@smithy/util-waiter/dist-es/waiter.js", "../../../../../node_modules/@smithy/util-waiter/dist-es/utils/sleep.js", "../../../../../node_modules/@smithy/util-waiter/dist-es/poller.js", "../../../../../node_modules/@smithy/util-waiter/dist-es/utils/validate.js", "../../../../../node_modules/@smithy/util-waiter/dist-es/createWaiter.js"],
  "sourcesContent": ["export const waiterServiceDefaults = {\r\n    minDelay: 2,\r\n    maxDelay: 120,\r\n};\r\nexport var WaiterState;\r\n(function (WaiterState) {\r\n    WaiterState[\"ABORTED\"] = \"ABORTED\";\r\n    WaiterState[\"FAILURE\"] = \"FAILURE\";\r\n    WaiterState[\"SUCCESS\"] = \"SUCCESS\";\r\n    WaiterState[\"RETRY\"] = \"RETRY\";\r\n    WaiterState[\"TIMEOUT\"] = \"TIMEOUT\";\r\n})(WaiterState || (WaiterState = {}));\r\nexport const checkExceptions = (result) => {\r\n    if (result.state === WaiterState.ABORTED) {\r\n        const abortError = new Error(`${JSON.stringify({\r\n            ...result,\r\n            reason: \"Request was aborted\",\r\n        })}`);\r\n        abortError.name = \"AbortError\";\r\n        throw abortError;\r\n    }\r\n    else if (result.state === WaiterState.TIMEOUT) {\r\n        const timeoutError = new Error(`${JSON.stringify({\r\n            ...result,\r\n            reason: \"Waiter has timed out\",\r\n        })}`);\r\n        timeoutError.name = \"TimeoutError\";\r\n        throw timeoutError;\r\n    }\r\n    else if (result.state !== WaiterState.SUCCESS) {\r\n        throw new Error(`${JSON.stringify(result)}`);\r\n    }\r\n    return result;\r\n};\r\n", "export const sleep = (seconds) => {\r\n    return new Promise((resolve) => setTimeout(resolve, seconds * 1000));\r\n};\r\n", "import { sleep } from \"./utils/sleep\";\r\nimport { WaiterState } from \"./waiter\";\r\nconst exponentialBackoffWithJitter = (minDelay, maxDelay, attemptCeiling, attempt) => {\r\n    if (attempt > attemptCeiling)\r\n        return maxDelay;\r\n    const delay = minDelay * 2 ** (attempt - 1);\r\n    return randomInRange(minDelay, delay);\r\n};\r\nconst randomInRange = (min, max) => min + Math.random() * (max - min);\r\nexport const runPolling = async ({ minDelay, maxDelay, maxWaitTime, abortController, client, abortSignal }, input, acceptorChecks) => {\r\n    const { state, reason } = await acceptorChecks(client, input);\r\n    if (state !== WaiterState.RETRY) {\r\n        return { state, reason };\r\n    }\r\n    let currentAttempt = 1;\r\n    const waitUntil = Date.now() + maxWaitTime * 1000;\r\n    const attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;\r\n    while (true) {\r\n        if (abortController?.signal?.aborted || abortSignal?.aborted) {\r\n            return { state: WaiterState.ABORTED };\r\n        }\r\n        const delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);\r\n        if (Date.now() + delay * 1000 > waitUntil) {\r\n            return { state: WaiterState.TIMEOUT };\r\n        }\r\n        await sleep(delay);\r\n        const { state, reason } = await acceptorChecks(client, input);\r\n        if (state !== WaiterState.RETRY) {\r\n            return { state, reason };\r\n        }\r\n        currentAttempt += 1;\r\n    }\r\n};\r\n", "export const validateWaiterOptions = (options) => {\r\n    if (options.maxWaitTime < 1) {\r\n        throw new Error(`WaiterConfiguration.maxWaitTime must be greater than 0`);\r\n    }\r\n    else if (options.minDelay < 1) {\r\n        throw new Error(`WaiterConfiguration.minDelay must be greater than 0`);\r\n    }\r\n    else if (options.maxDelay < 1) {\r\n        throw new Error(`WaiterConfiguration.maxDelay must be greater than 0`);\r\n    }\r\n    else if (options.maxWaitTime <= options.minDelay) {\r\n        throw new Error(`WaiterConfiguration.maxWaitTime [${options.maxWaitTime}] must be greater than WaiterConfiguration.minDelay [${options.minDelay}] for this waiter`);\r\n    }\r\n    else if (options.maxDelay < options.minDelay) {\r\n        throw new Error(`WaiterConfiguration.maxDelay [${options.maxDelay}] must be greater than WaiterConfiguration.minDelay [${options.minDelay}] for this waiter`);\r\n    }\r\n};\r\n", "import { runPolling } from \"./poller\";\r\nimport { validateWaiterOptions } from \"./utils\";\r\nimport { waiterServiceDefaults, WaiterState } from \"./waiter\";\r\nconst abortTimeout = async (abortSignal) => {\r\n    return new Promise((resolve) => {\r\n        const onAbort = () => resolve({ state: WaiterState.ABORTED });\r\n        if (typeof abortSignal.addEventListener === \"function\") {\r\n            abortSignal.addEventListener(\"abort\", onAbort);\r\n        }\r\n        else {\r\n            abortSignal.onabort = onAbort;\r\n        }\r\n    });\r\n};\r\nexport const createWaiter = async (options, input, acceptorChecks) => {\r\n    const params = {\r\n        ...waiterServiceDefaults,\r\n        ...options,\r\n    };\r\n    validateWaiterOptions(params);\r\n    const exitConditions = [runPolling(params, input, acceptorChecks)];\r\n    if (options.abortController) {\r\n        exitConditions.push(abortTimeout(options.abortController.signal));\r\n    }\r\n    if (options.abortSignal) {\r\n        exitConditions.push(abortTimeout(options.abortSignal));\r\n    }\r\n    return Promise.race(exitConditions);\r\n};\r\n"],
  "mappings": "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",
  "names": ["WaiterState", "state", "reason"]
}
